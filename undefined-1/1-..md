# 1장. 맛보기 예제

## 01. 원래의 프로그램

1 .기존 프로그램의 문제

* 문제 코드
  * ```text
    class Customer{


       public String statement(){
   
           double totalAmount = 0;
           int frequentRenterPoints = 0;
           Enumeration rentals = _rentails.elements();
           String result = getName() + "고객님의 대여 기록\n";
           while(rentals.hasMoreElements()){
               double thisAmount = 0;
               Rental each = (Rental) rentals.nextElement();
           
           
               // 비디어 종류별 대여 계싼 
               switch(each.getMovie().getPriceCode()){
                  case Movie.REGULAR;
                     thisAmount += 2;
                     if(each.getDaysRented() >2)
                         thisAmount += (each.getDaysRented) -2) * 1.5
                     break;
                  case Movie.NEW_RELEASE;
                     thisAmount += each.getDaysRented() *3;
                     break;
                  case Movie.CHILDRENS;
                     thisAmount += 1.5;
                     if(each.getDaysRented()>3)
                        thisAmount += (each.getDaysRented() -3) *1.5;
                     break;      
               }
           
           
               // 적립 포인트를 1포인트 증가
               frequentRenterPoints ++;
               // 최신물을 이틀 이상 대여하면 보너스 포인트 지급
               if((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
                   && each.getDaysRented() >1){
                   frequentRenterPoints ++;   
                }
            
                // 이번에 대여하는 비디오 정보와 대여료를 출력
                result += "\t" + each.getMovie().getTitle() + "\t"
                       + String.valueOf(thisAmount) + "\n"
                // 현재까지 누적된 총 대여료
                totalAmount += thisAmount; 
       
       
       
           }


        }



    }
    ```
* 문제점

  * 하나의 메소드에 수많은 기능이 존재
  * 다른 클래스에 있어야 할 메소드가 존재
  * 

* 발생되는 문제

  * 확장성이 어렵다.  

 

* 이때 해야하는것
  * 리팩토링
    * 기능을 추가하기 쉽게 만들어 확장성을 향상시킨다. 



## 02. 리팩토링 첫 단계

1 . 테스트 코드 작성

* 리팩토링할 코드 부분에 대한 신뢰도 높은 각종 테스트를 작성
  * 리팩토링 과정에서 발생할 수 있는 문제들을 탐지하기 위해 



* 적절한 테스트코드의 작성은 리팩토링의 기본 
  * 코드 수정 중 버그의 생성 유무를 확인 가능 



## 03. statement 메소드 분해와 기능 재분해

### 1 . statemet 매소드 분해 

* 긴 메소드를 분해하여 각 부분을 알맞은 클래스로 옮기는 것 
  * 방법
    * 메소드 추출  \[intellij : Ctrl + Alt +  m\] 
* 메소드 추출 전 확인해야 할 요소들

  * 모든 지역변수와 매개변수들  여기서 변경되지 않은 변수는 매개변수로 전달할 수 있다.
    * 변경되는 변수 : thisAmount
    * 변경되지 않은 변수 : each 
  * 변경되는 변수가 하나뿐이라면 그 변수를 반환할 수 잇다.  

* 리팩토링의 장점
  * 조금씩 단계적으로 수정하므로, 실수해도 버그를 찾기가 쉽다. 
* 메소드 추출 후 변경된 코드
  * ```text
    class Customer{


       public String statement(){
   
           double totalAmount = 0;
           int frequentRenterPoints = 0;
           Enumeration rentals = _rentails.elements();
           String result = getName() + "고객님의 대여 기록\n";
           while(rentals.hasMoreElements()){
               double thisAmount = 0;
               Rental each = (Rental) rentals.nextElement();
           
           
               // 비디어 종류별 대여 계싼 

           
               thisAmount = amountFor(each);
           
           
               // 적립 포인트를 1포인트 증가
               frequentRenterPoints ++;
               // 최신물을 이틀 이상 대여하면 보너스 포인트 지급
               if((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
                   && each.getDaysRented() >1){
                   frequentRenterPoints ++;   
                }
            
                // 이번에 대여하는 비디오 정보와 대여료를 출력
                result += "\t" + each.getMovie().getTitle() + "\t"
                       + String.valueOf(thisAmount) + "\n"
                // 현재까지 누적된 총 대여료
                totalAmount += thisAmount; 
       
       
       
           }


        }
    
        // 비디오 종류별 대여료 계산 기능을 빼내어
        // 별도의 함수로 작성 
        private double amountFor(Rental each){
            
             double thisAmount = 0;
             switch(each.getMovie().getPriceCode()){
                  case Movie.REGULAR;
                     thisAmount += 2;
                     if(each.getDaysRented() >2)
                         thisAmount += (each.getDaysRented) -2) * 1.5
                     break;
                  case Movie.NEW_RELEASE;
                     thisAmount += each.getDaysRented() *3;
                     break;
                  case Movie.CHILDRENS;
                     thisAmount += 1.5;
                     if(each.getDaysRented()>3)
                        thisAmount += (each.getDaysRented() -3) *1.5;
                     break;      
             }
         
             return thisAmount;
        }



    }
    ```
  * 



### 2 . 직관성을 향상시키기 위한 변수명 수정

* ```text
      private double amountFor(Rental rental){
            
           double result = 0;
           switch(rental.getMovie().getPriceCode()){
                case Movie.REGULAR;
                   result += 2;
                   if(rental.getDaysRented() >2)
                       result+= (rental.getDaysRented) -2) * 1.5
                   break;
                case Movie.NEW_RELEASE;
                   result += rental.getDaysRented() *3;
                   break;
                case Movie.CHILDRENS;
                   result += 1.5;
                   if(rental.getDaysRented()>3)
                      result += (rental.getDaysRented() -3) *1.5;
                   break;      
           }
         
           return result;
      }
  ```







### 3 . 대여료 계 메소드 옮기기

* amountFor 메소드는 Rental 클래스의 정보를 이용하고, 자신이 속한 Customer 클래스의 정보는 이용하지 않음 
  * 메소드는 대체로 자신이 사용하는 데이터와 같은 객체에 있어야 한다.
  * 따라서 \[메소드 이동, Move Method\]기법을 실시하여 Rental 클래스로 이동시킨다. 
* Rental 클래스로 옮겨진 코드
  * ```text
    class Rental{
      ...
      double getCharge(){
             double result = 0;
             switch(getMovie().getPriceCode()){
                  case Movie.REGULAR;
                     result += 2;
                     if(getDaysRented() >2)
                         result+= (getDaysRented) -2) * 1.5
                     break;
                  case Movie.NEW_RELEASE;
                     result += getDaysRented() *3;
                     break;
                  case Movie.CHILDRENS;
                     result += 1.5;
                     if(getDaysRented()>3)
                        result += (getDaysRented() -3) *1.5;
                     break;      
             }
         
             return result;
        }

    }
    ```
  * 이때 Rental 클래스에 맞게 수정한다는 의미
    * 매게변수 삭제를 의미
  * 옮기는 과정에서 메소드 명도 수정  
* 이후 옮긴 메소드를 Customer 클래스에서 사용하게 한다.

  * ```text
    class Customer{
      ....
      private double amountFor(Rental aRental){
         return aRental.getCharge();
      }

    }
    ```



* 이후 기존 메소드 참조 부분을 전부 찾아서, 새 메소드 참조로 수정
  * ```text
    class Customer{


       public String statement(){
   
           double totalAmount = 0;
           int frequentRenterPoints = 0;
           Enumeration rentals = _rentails.elements();
           String result = getName() + "고객님의 대여 기록\n";
           while(rentals.hasMoreElements()){
               double thisAmount = 0;
               Rental each = (Rental) rentals.nextElement();
           
           
               // 비디어 종류별 대여 계 
               //thisAmount = amountFor(each); 을
               thisAmoubt = each.getCharge(); 로 수정 
           
           
               // 적립 포인트를 1포인트 증가
               frequentRenterPoints ++;
               // 최신물을 이틀 이상 대여하면 보너스 포인트 지급
               if((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
                   && each.getDaysRented() >1){
                   frequentRenterPoints ++;   
                }
            
                // 이번에 대여하는 비디오 정보와 대여료를 출력
                result += "\t" + each.getMovie().getTitle() + "\t"
                       + String.valueOf(thisAmount) + "\n"
                // 현재까지 누적된 총 대여료
                totalAmount += thisAmount; 

       
           }
           // 푸터 행 추가
           result += "누적 대여료 : " 
                      + String.valueOf(totalAmount) + "\n";
           result += "적립 포인트: " 
                       + String.valueOf(frequentRenterPoint);
           return result            
                  


        }
    
    }
    ```



* charge 메소드를 옮긴 후의 클래스 관계
  * 

![](../.gitbook/assets/87.png)



### 4 . 변수의 불필요한 중복 제거

* thisAmount 변수는 메소드의 결과를 저장하는데만 사용되고, 그 후에는 전혀 사용되지 않음 
* 이때  \[임시변수를 메소드 호출로 전환, Replace Temp with Query\]기법을 사용하여 thisAmount 변수를 삭제해야 한다. 





* 변경된 코드
  * ```text
     public String statement(){
   
           double totalAmount = 0;
           int frequentRenterPoints = 0;
           Enumeration rentals = _rentails.elements();
           String result = getName() + "고객님의 대여 기록\n";
           while(rentals.hasMoreElements()){
               double thisAmount = 0;
               Rental each = (Rental) rentals.nextElement();
           
           

           
               // 적립 포인트를 1포인트 증가
               frequentRenterPoints ++;
               // 최신물을 이틀 이상 대여하면 보너스 포인트 지급
               if((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
                   && each.getDaysRented() >1){
                   frequentRenterPoints ++;   
                }
            
                // 이번에 대여하는 비디오 정보와 대여료를 출력
                result += "\t" + each.getMovie().getTitle() + "\t"
                       + String.valueOf(each.getCharge) + "\n"
                // 현재까지 누적된 총 대여료
                totalAmount += each.getCharge; 

       
           }
           // 푸터 행 추가
           result += "누적 대여료 : " 
                      + String.valueOf(totalAmount) + "\n";
           result += "적립 포인트: " 
                       + String.valueOf(frequentRenterPoint);
           return result            
                  


        }
    ```



* 임시변수는 최대한 없애는 것이 좋다.
  * 이유
    * 임시변수가 많은면 불필요하게 많은 매개변수를 전달하게 되는 문제가 발생
    * 임시변수의 용도를 차츰 잊기 쉽상
    * 성능 저하 문제 





### 5. 적립 포인트 계산을 메소드로 빼기

* 적립 포인트 계산 메소
  * 코드
    * ```text
      // 적립 포인트를 1포인트 증가
      frequentRenterPoints ++;
      // 최신물을 이틀 이상 대여하면 보너스 포인트 지급
      f((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
          && each.getDaysRented() >1){
          frequentRenterPoints ++;   
      }
      ```
  * 이 코드를 메소드 추출 기법을 적용한 후, Rental 클래스로 이동
  * 이때 each와 frequentRenterPoint 임시 변수가 사용됐는데, 이때  frequentRenterPoint 변수에는 미리 값이 들어있다.
  * 그러나 추출한 메소드 안의 코드는 이 값을 읽을 수 없으니, 대입문을 추가로 작성하면 이 임시변수를 매개변수로 전달할 필요 없다.  
  * 이후 기능을 변경하여, 경우에 따라 포인트를 달리 지급하게 한다.  



* 리팩토링 후의 메소드 
  * Customer
    * ```text
       public String statement(){
   
             double totalAmount = 0;
             int frequentRenterPoints = 0;
             Enumeration rentals = _rentails.elements();
             String result = getName() + "고객님의 대여 기록\n";
             while(rentals.hasMoreElements()){
                 double thisAmount = 0;
                 Rental each = (Rental) rentals.nextElement();
           
           

           
                 frequentRenterPoints 
                     +=each.getFrequentRenterPoints();
            
                  // 이번에 대여하는 비디오 정보와 대여료를 출력
                  result += "\t" + each.getMovie().getTitle() + "\t"
                         + String.valueOf(each.getCharge) + "\n"
                  // 현재까지 누적된 총 대여료
                  totalAmount += each.getCharge; 

       
             }
             // 푸터 행 추가
             result += "누적 대여료 : " 
                        + String.valueOf(totalAmount) + "\n";
             result += "적립 포인트: " 
                         + String.valueOf(frequentRenterPoint);
             return result            
                  


      }
      ```
  * Rental
    * ```text
      int getFrequentRenterPoints(){
         if((each.getMovie().getPriceCode == Movie.NEW_RELEASW)
             && each.getDaysRented() >1){
             return 2; 
         }else{
             return 1;
         }

      }
      ```
    * 





### 6. 임시변수 없애기 2

* totalAmount 변수와 frequentRentalPoints 변수를 질의 메소드로 고칠 것  
* cf\) 질의 메소드
  * 필요한 값을 반환하고자 호출되는 메소드  
* 변경된 후의 메소드 
  * ```text
    public String statement(){
  
           Enumeration rentals = _rentails.elements();
           String result = getName() + "고객님의 대여 기록\n";
           while(rentals.hasMoreElements()){
               Rental each = (Rental) rentals.nextElement();
           
            
                // 이번에 대여하는 비디오 정보와 대여료를 출력
                result += "\t" + each.getMovie().getTitle() + "\t"
                       + String.valueOf(each.getCharge) + "\n"

       
           }
           // 푸터 행 추가
           result += "누적 대여료 : " 
              + String.valueOf(getTotalCharge()) + "\n";
           result += "적립 포인트: " 
               + String.valueOf(getTotalFrequentRenterPoints());
           return result            
                  


    }

    private double getTotalCharge(){
        int result = 0;
        Enumeration retals = _rentals.elements();
        while(rentals.hasmoreElements() ){
           Rental each = (Rental) rentals.nextElement();
           result ++ each.getCharge();
        }
        return result;

    }


    private int getTotalFrequentRenterPoints(){
        int result = 0;
        Enumeration retals = _rentals.elements();
        while(rentals.hasmoreElements() ){
           Rental each = (Rental) rentals.nextElement();
           result ++ each.getFrequentRenterPointers();
        }
        return result;

    }
    ```







### 7. 이제까지의 리팩토링 회고

* 현재 리팩토링의 단점
  * 1 . 코드가 너무 길어짐
  * 2 . 성능 문제
    * while문 횟수가 1번에서 3번으로 늘어남 







## 04. 가격 책정 부분의 조건문을 재정의로 교체

0. 발생한 요구사항

* 대여점의 비디오 분류를 변경 
  * 기존과는 완전히 다른 방식으로 경될 예정 



### 1 . switch 문 변경 

* switch문의 인자로 타 객체의 데이터를 사용하지 말고, 자신의 데이터를 사용하도록 변경  
* 1 . getCharge 메소드를 Rental 클래스에 Movie 클래스로 옮김
  * ```text
    class Movie{
      double getCharge(int daysRented){
             double result = 0;
             switch(getMovie().getPriceCode()){
                  case Movie.REGULAR;
                     result += 2;
                     if(getDaysRented() >2)
                         result+= (getDaysRented) -2) * 1.5
                     break;
                  case Movie.NEW_RELEASE;
                     result += getDaysRented() *3;
                     break;
                  case Movie.CHILDRENS;
                     result += 1.5;
                     if(getDaysRented()>3)
                        result += (getDaysRented() -3) *1.5;
                     break;      
             }
         
             return result;
        }

    }
    ```
  * 수정 코드가 제대로 돌아가게 하기 위해 대여 기간을 전달 
    * 이때 대여 기간은 Rental 클래스에 있는 데이 
  * 대여기간을 Rental 클래스에 전달하지 않고, Movie 클래스에 전달한 이유
    * 비디오 종류에 대한 정보는 나중에 변경할 가능성이 높다.
    * 비디오 종류를 변경해도, 그로인해 미치는 영향을 최소화하고자 대여료 계산을 Movie 클래스 안에 넣은 것    
  * Rental 클래스
    * ```text
      class Rental{
        ...
        double getCharge(){
           return _movie.getCharge(_daysRented);
        }
      }
      ```
    * 
  * 이후 getCharge 메소드를 옮겼으면, 적립 포인트 계산 메소드로 옮긴다.
    * 이렇게 되면, 대여료  및 적립 ㅗ인트 계싼이





* 






## 05. 고

