# 17. 쉘 스크립트



## 01. 쉘 스크립트 <a id="01.-&#xC258;-&#xC2A4;&#xD06C;&#xB9BD;&#xD2B8;"></a>

### 1 . 쉘 스크립트 <a id="1-.-&#xC258;--&#xC2A4;&#xD06C;&#xB9BD;&#xD2B8;"></a>

* 쉘을 이용하여 프로그래밍을 할 수 있다.  
* 서버 작업 자동화 및 운영을 위해 기본적으로 익혀두어야 한다.  
* 쉘 명령어를 기본으로 하되, 몇 가지 문법이 추가된 형태  
* 시스템 프로그래밍에서 필수적인 내용  
* 쉘 명령어 익힌 후, 쉘 스크립트

### 2. 쉘 스크립트 예시 <a id="2.-&#xC258;-&#xC2A4;&#xD06C;&#xB9BD;&#xD2B8;-&#xC608;&#xC2DC;"></a>

* 문제점
  * 서버가 어느날 다운, 원인은 로그 파일의 축적으로 서버 공간이 다 참 어떻게 하면 **자동**으로 로그 파일들을 삭제할 것인가?  
* 해결방법
  * 간단한 쉘 스크립트 생성하여 주기적으로 실행

### 3. 기본 문법 <a id="3.-&#xAE30;&#xBCF8;-&#xBB38;&#xBC95;"></a>

* 쉘 스크립트는 파일로 작성 후, 그 파일을 실행한다.  
* 파일의 가장 첫 라인은 \[\#!/bin/bash\]로 시작한다.  
* 쉘 스크립트 파일은 실행 권한을 가지고 있어야 한다.
  * ex\) rwx  
* 일반적으로 \[파일이름.sh\]와 같은 형태로 파일 이름을 작성한다.

### 4. 실습 <a id="4.-&#xC2E4;&#xC2B5;"></a>

* **bash 쉘**에서 제공하는 echo 함수\(정확히는 쉘 명령어\)를 이용하여 화면에 “hello world”를 출력하는 스크립트
  * vi hello.sh 로 생성
  * ```text
    #!/bin/bash

    echo 'Hello Bash!'
    ```

    * 이후 저장하고, 권한이 없을 경우, chmod 777 hello.sh 를 통해 권한을 준다.  
    *  그 다음 path가 잡혀있지 않으니, ./hello.sh 로 실행  
* 이후 변수. 조건문, 반복문을 추가하여 더 나은 스크립트 생성 가능  
* 주석을 사용할 경우, \[\#\] 기호로 시작하면, 그 라인은 주석처리된다.

## 02. 이해와 변수  <a id="02.-&#xC774;&#xD574;&#xC640;-&#xBCC0;&#xC218;"></a>

### 1 . 변수 <a id="1-.-&#xBCC0;&#xC218;"></a>

* 선언방법
  * \[변수명=데이터\]
  * \[변수명=데이터\] 사이에 띄어쓰기는 허용되지 않는다. 
* 사용법
  * $변수명 으로 사용된다.  
* 예시
  * ```text
    예)
    #!/bin/bash
    mysql_id='root'
    mysql_directory='/etc/mysql'
    echo $mysql_id
    echo $mysql_directory
    ```
* 실습
  * 아이디 관련 정보 변수 만들기
    * ```text
      #!/bin/bash

      name='ubuntu'
      age='27'
      job='none'

      echo $name
      echo $age
      echo $job

      또는
      echo $name $age $job // 한줄로 출력된다. 
      ```

### 2 . 리스트 변수\(배열\) <a id="2-.-&#xB9AC;&#xC2A4;&#xD2B8;-&#xBCC0;&#xC218;(&#xBC30;&#xC5F4;)"></a>

* 선언방법
  * 변수명=\(데이터1데이터2데이터3..\)  
* 사용
  * ${변수명\[인덱스번호\]}  
* 코드 예시
  * ```text
    #!/bin/bash
    daemons=("httpd" "mysqld" "vsftpd")
    echo ${daemons[1]} # $daemons 배열의 두 번째 인덱스에 해당하는 mysqld 출력
    echo ${daemons[@]} # $daemons 배열의 모든 데이터 출력
    echo ${daemons[*]} # $daemons 배열의 모든 데이터 출력
    echo ${#daemons[@]} # $daemons 배열 크기 출력

     # 해당 쉘스크립트 실행 디렉토리의 파일 리스트를 배열로 $filelist 변수에 입력
    # 즉, 결과값이 filelist의 배열로 들어가게 된다. 
    # 이때 
    filelist=( $(ls) )
 
    echo ${filelist[*]} # $filelist 모든 데이터 출력
    ```
  * 만약 ${daemons\[\]} 대신 $daemons\[\] 로 쓰면, 쉘 스크립트는 daemons까지만 변수로 인식하고, 이때 1개만 출력이 되야 하기 때문에 0번째 값이 출력이 되고, 이후의 \[\] 부터는 일반적인 string으로 인식하여 httpd\[1\]로 출력이 된다.
  * 따라서 {} 를 사용해야 전체를 다 변수로 인식한다.   
* 쉘 스크립트는 기본문법과 가변문법이 있다.
  * 버전 등에 따라 문법이 조금씩 변할 수있기 때문에 가변문법이 만들어짐
* 실습
  * 조건
    * 실제이름\(0번 인덱스\)
    * 나이\(1번 인덱스\)
    * 직업\(1번 인덱스\)  
  * 코드
    * ```text
      #!/bin/bash
      myinfo("ubuntu" 13 "none")
      echo ${myinfo[0]}
      echo ${myinfo[1]}
      echo ${myinfo[2]}
      ```

### 3. 사전에 정의된 지역변수들 <a id="3.-&#xC0AC;&#xC804;&#xC5D0;-&#xC815;&#xC758;&#xB41C;-&#xC9C0;&#xC5ED;&#xBCC0;&#xC218;&#xB4E4;"></a>

* 종류
  * ```text
    $$ : 쉘 스크립트 프로세스 번호
    $0 : 쉘스크립트 이름
    $1 ~ $9 : 명령줄 인수
    $* : 모든 명령줄 인수리스트
     // 이름을 제외한 나머지 인자
 
    $# : 인수의 개수
    // 이름을 제외한 나머지 인자의 갯수
    $? : 최근 실행한 명령어의 종료 값

    - 0 (성공), 1 ~ 125 (에러),
    - 126 (파일이 실행가능하지 않음),
    - 128 ~ 255 (시그널 발생)
    ```
  * 
* 실습
  * 조건
    * 쉘 프로세스 번호, 쉘스크립트 이름, 명령줄 인수, 모든 명령줄 인수리스트, 인수 개수 출력해보기
  * 코드
    * ```text
      #!/bin/bash

      echo $$ $0 $1 $* $#
      ```

### 4. 연산자 <a id="4.-&#xC5F0;&#xC0B0;&#xC790;"></a>

* 종류
  * expr
    * 숫자계산
    * 사용할 때는 따옴표\(\`\) 를 사용해야 한다.
    * 연산자 \* 와 괄호\(\) 앞에는\[ \(와 \) 둘 다\] 역슬레시\(\) 와 같이 사용한다.
    * 연산자와 숫자, 변수, 기호 사이에는 space를 넣어야 한다.
  * 예시
    * ```text
      num=`expr \(3\*5\) / 4 + 7`
      echo $num
      ```
  *  expr 는 정수가 아닌 계산은 못한다
* 문의
  * 질문
    * ```text
      시스템 프로그래밍 자료 33_36장 쉘 스크립트.pdf 자료 15쪽 예제 코드에서
      expr 은 정수만 가능한데, 실수로 결과가 나와버려서 오류가 생겼습니다.
      검색 결과 bc 등을 사용하면 실수도 표현이 가능하다고 해서
      #!/bin/bash
      num="(3*5)/4+7" | bc
      echo $num
      이렇게 작성했더니 실행 결과가
      ubuntu@ip-172-31-44-84:~$ ./calculate.sh
      ubuntu@ip-172-31-44-84:~$ vi calculate.sh
      와 같이 결과값이 안나오고 공백이 나왔습니다.
      Q1. 왜 공백이 나오는지 궁금합니다.

      Q2. 또한 실수를 변수에 대입할 때
      저렇게 사용하는것이 맞는지도 궁금힙ㄴ다.
      ```
  * 답변
    * ```text
      A1 
      실행 결과를 변수에 담을 때는 `(백틱, 원화표시)으로 감싸야 합니다.
      그리고 다음과 같이 써야 올바르게 실행이 됩니다.
      num=`echo "(3*5)/4+7" | bc`
      ```
    * ```text
      A2
      해당 코드를 실행해보면 결과가 10이 나옵니다.
      bc 뒤에 -l을 붙이면 10.75000000000000000000이 나옵니다
      ```

## 03. 조건문 <a id="03.-&#xC870;&#xAC74;&#xBB38;"></a>

### 1 . 조건문 문법 <a id="1-.-&#xC870;&#xAC74;&#xBB38;-&#xBB38;&#xBC95;"></a>

* 기본 if 구문
  * 코드
    * ```text
      if [ 조건 ]
      then  //  [{] 와 같다.
          명령문
      fi // [}] 와 같다.
      ```
*  명령문을 꼭 탭으로 띄어야 하는 것은 아니다
  * 띄우는 이유는 가독성 때문
* 실습
  * 조건
    * 두 인자값을 받을 때, 두 값이 서로 다르면 ‘different values’ 를 출력  
  * 코드
  * ```text
    #!/bin/bash

    first=$1
    second=$2

    if [ first != second ]
    then
            echo 'different value'
            fi

    ```

### 3 . 조건 <a id="3-.-&#xC870;&#xAC74;"></a>

* 문자 비교
  * 문자1 == 문자2
    * 문자1과 문자2가 일치  
  * 문자1 != 문자2
    * 문자1 과 문자2가 일치하지 않음  
  * -z 문자
    * 문자가 null 이면 참  
  * -n 문자
    * 문자가 null 이 아니면 참  
* 수치 비교
  * &lt; 와 &gt; 는 if 조건 시 \[\[\]\]를 넣는 경우 정상 동작하기도 하지만,
    * ex\)
      * \[ $1 &gt; $2 \] 또는 \[\[ $1 &gt; $2 \]\]  
  * 기본적으로 다음 문법을 사용하는 것을 권장한다.
    * \[\] 안에 쓰면 된다.
    * 값1 -eq 값2
      * 값이 같다.  
    * 값1 -ne 값2
      * 값이 같지 않다.  
    * 값1 -lt 값2
      * 값1이 2보다 작다  
    * 값1 -le 값2
      * 값1이 2보다 작거나 같다.  
    * 값1 -gt 값2
      * 값 1이 2보다 크다  
    * 값1 -ge 값2
      * 값 1이 2 이상이다.
* 실습
  * 조건
    * 첫 번째 인자값이 두 번째 인자값보다 크면, 이를 출력하는 코드  
  * 코드
    * ```text
      #!/bin/bash

      if [ $1 -gt $2]
      then
        echo $1
        fi
      ```

### 4. 파일 검사 <a id="4.-&#xD30C;&#xC77C;-&#xAC80;&#xC0AC;"></a>

* 파일 검사 방법
  * -e 파일명
    * \# 파일이 존재하면 참
  * -d 파일명
    * \# 파일이 디렉토리면 참
  * -h 파일명
    * \# 심볼릭 링크파일
  * -f 파일명
    * \# 파일이 일반파일이면 참
  * -r 파일명
    * \# 파일이 읽기 가능이면 참
  * -s 파일명
    * \# 파일 크기가 0이 아니면 참
  * -u 파일명
    * \# 파일이 set-user-id가 설정되면 참
  * -w 파일명
    * \# 파일이 쓰기 가능 상태이면 참
  * -x 파일명
    *  \# 파일이 실행 가능 상태이면 참  
* 실습
  * 조건
    * 해당 파일이 있는지 없는지를 출력하는 쉘 스크립트 작성해보기  
  * 코드
    * ```text
      #!/bin/bash

      if [ -e $1 ]
      then
         echo 'exist'
         exit
      fi


      echo 'non exist'

      ```
    * 

### 5. 논리연산 <a id="5.-&#xB17C;&#xB9AC;&#xC5F0;&#xC0B0;"></a>

* 코드
  * 조건1 -a 조건2
    *  \# AND  
  * 조건1 -o 조건2
    *  \# OR  
  * 조건1 && 조건2
    * \# 양쪽 다 성립  
  * 조건1 \|\| 조건2
    * \# 한쪽 또는 양쪽다 성립  
  * !조건
    * \# 조건이 성립하지 않음  
  * true
    * \# 조건이 언제나 성립  
  * false
    *  \# 조건이 언제나 성립하지 않음   

### 6. if - else 구문 <a id="6.-if---else-&#xAD6C;&#xBB38;"></a>

* 코드
  * ```text
    if [ 조건 ]
    then
         명령문
    else
         명령문
    fi
    ```
* 실습
  * 조건
    * 두 인자값을 받아서, 두 인자값이 같으면 ‘same value’를 출력, 그렇지 않으면 ‘different values’를 출력  
  * 코드
    * ```text
      #!/bin/bash

      if [ $1 -eq $2 ]
      then
        echo 'same'
      else
        echo 'difference'
      fi
      ```
* 실습2 - 쉘 스크립트 해석하기
  * 명령 해석
    * ping \[옵션\] \[ip주소\] \[옵션\]
    * ping
      * 서버는 항상 여러 컴퓨터들이 인터넷에 연결되어 있는 환경
      * 인터넷에 연결되어 있다는 것은 주소가 부여되어 있다는 것 즉, ip 주소를 가지고 있다.  
      * ping 은 서버에서 여러개의 컴퓨터가 연결되어 있을 때, 연결되어 잇는 특정 컴퓨터가 정상적으로 동작하는지, 비정상적으로 동작하는지 확인하는 프로그램  
      * 방법
        * 해당 ip 주소로 ping 이라는 명령 실행하여 확인 요청을 한다.
        * 확인 요청을 받으면 정상적인 컴퓨터는 정상적으로 동작한다는 응답를 보낸다.  
        * 일정시간동안 응답이 오지 않으면 정상적으로 동작하지 않는다고 판단   
    * 옵션 ex\) ping -c 1
      * -c 1 : 1번만 확인요청해라  
    * 코드 예시
      * ping -c 1 192.168.0.1 1&gt; /dev/null
        * -c 1
          * 1번만 확인요청하라는 의미  
        * 1&gt; /dev/null
          * 0 : 표준 입력, 1: 표준 출력, 2: 표준 에러
          * 의미 표준 출력 내용을 /dev/null 에 보내라는 의미, 즉 출력하지 말라는 것
  * 예시
    * ```text
      #!/bin/bash
      ping -c 1 192.168.0.1 1> /dev/null // 출력하지 말라는 이야기
      // $? : 가장 최근 실행한 명령의 결과값
      // 0이라는 의미 : 응답을 받았다. 
      // 0이 아니라는 것 : 응답을 못받았다는 것 
      if [ $? == 0 ]  
      then
          echo "핑 성공"
      else
          echo "핑 실패"
      fi  
    
      ```
* 조건문 한 줄에 작성하기
  * if \[ 조건 \]; then 명령문; fi
    * ```text
      if [ -z $1 ]; then echo "Insert arguments"; fi
      ```
    * if \[ 뒤와 \] 앞에는 반드시 공백이 있어야 한다.
    * \[\] 에서 &&, \|\|, &lt;,&gt; 연산자들이 에러가 나는 경우는 \[\[\]\]를 사용하면 정상 작동하는 경우가 있다.

## 04. 반복문과 실제 예제 <a id="04.-&#xBC18;&#xBCF5;&#xBB38;&#xACFC;-&#xC2E4;&#xC81C;-&#xC608;&#xC81C;"></a>

### 1 . for 문 <a id="1-.-for-&#xBB38;"></a>

* 코드
  * ```text
    for 변수 in 변수값1 변수값2 ...
    do
    명령문
    done
    ```
  * 
* 실습1
  * 조건
    * 현재 디렉토리에 있는 파일과 디렉토리 출력  
  * 코드
    * ```text
      #!/bin/bash

      for database in $(ls)
      do
        echo $database
      done  
      ```
* 반복문 짧게 작성하기
  * ```text
    #!/bin/bash
    for database in $(ls); do echo $database; done
    ```
  * ```text
    #!/bin/bash
    for database in $(ls); do
        echo $database
    done
    ```

### 2. while 문 <a id="2.-while-&#xBB38;"></a>

* 기본 문법
  * 코드
    * ```text
      while [ 조건문 ]
      do
           명령문
      done
      ```
  * 
* 실습
  * 조건
    * 현재 디렉토리에 있는 파일과 디렉토리 출력  
  * 코드
    * ```text
      #!/bin/bash
      lists=$(ls)
      num=${#lists[@]} // lists 변수들의 갯수 
      index=0
      while [ $num -ge 0 ] // num 이 0 이상이면,
      do
          echo ${lists[$index]}
          index=`expr $index + 1`
          num=`expr $num - 1`
      done
      ```
  * 

## 05. 협업 예제 및 정리 <a id="05.-&#xD611;&#xC5C5;-&#xC608;&#xC81C;-&#xBC0F;-&#xC815;&#xB9AC;"></a>

### 1. 백업하기 <a id="1.-&#xBC31;&#xC5C5;&#xD558;&#xAE30;"></a>

* 코드
  * ```text
    #!/bin/bash
    if [ -z $1 ]||[ -z $2 ]; then
         echo usage: $0(쉘 이름) sourcedir(압축할 디렉토리) targetdir(압축된 파일을 넣을 디렉토리)
    else
         SRCDIR=$1
         DSTDIR=$2

         BACKUPFILE=backup.$(date +%y%m%d%H%M%S).tar.gz//백업할 파일 이름
         if [ -d $DSTDIR ]; then
              tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR
         else
              mkdir $DSTDIR
              tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR
         fi
    fi
    ```

    *  $\(date +%y%m%d%H%M%S\) 의 의미
      * 파일 이름을 다르게 하기 위해 date 라는 쉘 명령어를 사용해서 현재 이 시점의 %y 년, %m 월 …. 초 를 리턴해준다. 즉, 파일은 backup.현재시각.tar.gz 라는 이름으로 생성된다.  
    * \[ -d $DSTDIR\(압축된 파일을 넣을 디렉토리 명 \) \] 의 의미
      * 아직 압축된 파일을 넣을 디렉토리의 생성 유무를 확인
      * 없으면 mkdir 를 통해 디렉토리를 생성 후 넣어준다.   
    *  tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR
      *  $SRCDIR 안의 모든 파일들을 DSTDIR/ 안의 BACKUPFILE 명으로 압축  
*  압축명령 tar
  *  기능
    *  초기에는 여러 파일을 하나로 묶기만
    * 이후 gzip 이라는 압축 명령이 나와서, 이후 묶기만 하는 것이 아닌, 압축까지 할 수 있도록 확장
      * 즉. 특정 옵션을 사용하면, gzip 압축을 사용하여 묶어서 압축이 가능하게 되었다.  
  * 주요 옵션
    * x
      *  묶음을 해제
    * c
      * 파일을 묶음
    * v
      * 묶음/해제 과정을 화면에 표시
    * z
      * gunzip을 사용해서 압축
    * f
      * 파일 이름을 지정  
  * 압축시 주로 사용하는 옵션
    * ```text
       tar -cvzf [압축된 파일에 붙이고 싶은 이름] [압축할 파일이나 폴더명]

      ```
    * 
  * 압축 풀 때 주로 사용하는 옵션
    * ```text
      tar -xvzf [압축 해제할 압축 아카이브 이름(압축된 파일이름 )]

      ```
    * 

### 2 . 로그파일 정리하기 <a id="2-.-&#xB85C;&#xADF8;&#xD30C;&#xC77C;-&#xC815;&#xB9AC;&#xD558;&#xAE30;"></a>

* 코드
  * ```text
    find . -type f -name '파일명검색어' -exec bash -c "명령어1; 명령어2; 명령어3;" \;
    # -type f: 파일 타입 지정해서 검색(f는 일반 파일)
    ```

    *  . 의 의미
      * 현재 디렉토리  
    * \[-type f\] 의 의미
      * \[일반 파일 중\]  
    * \[파일명검색어\]
      * 주로 정규표현식으로 표현  
    * bash
      * 쉘은 bash를 쓴다는 의미  
    * \[명령어1, 명령어2 …. \]
      * 해당 파일들에 대해 쉘 명령어들을 실행
* 예제
  * 정책
    * 2일 이상 지난 로그파일들은 압축 후 보관
    * 이미 압축된 로그 파일 중 3일 이상 경과 된 것들은 삭제
  * ```text
    #!/bin/bash

    LOGDIR=/var/log
    GZIPDAY=1
    DELDAY=2
    cd $LOGDIR
    echo "cd $LOGDIR"

    sudo(LOGDIR 이 시스템 ) find . -type f -name '*log.?' -mtime +$GZIPDAY -exec bash -c "gzip {}" \; 2> /dev/
    sudo find . -type f -name '*.gz' -mtime +$DELDAY -exec bash -c "rm -f {}" \; 2>
    ```

    *  \[ -mtime +$GZIPDAY\] 의 의미
      * 파일의 생성 시간이 현재부터 \[1+$GZIPDAY \] 경과한 파일을 찾게 됨  
    * \[-mtime +$DELDAY\]
      * 위와 같다 .  
    * rm
      * y/n 묻지 말고 바로 삭제  
    * { }
      * 각각의 파일 리스트들이 들어

