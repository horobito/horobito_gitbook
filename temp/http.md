# HTTP 배운 내용 정리

만든이  
1. 김지환 : odkfu1@gmail.com - 나   
2. 장재혁 : obg2546@naver.com

## 00. 들어가기전에 <a id="00.-&#xB4E4;&#xC5B4;&#xAC00;&#xAE30;&#xC804;&#xC5D0;"></a>

### 1. 프로토콜이란? <a id="1.-&#xD504;&#xB85C;&#xD1A0;&#xCF5C;&#xC774;&#xB780;?"></a>

* 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계 
* 공통의 데이터 교환 방법 및 순서에 대해 정의한 의사소통의 약속, 규약 혹은 규칙 체계 
* 통신을 원하는 두 개체간에 무엇을, 어떻게, 언제 통신할 것인가를 서로 약속한 규약

### 2. 하이퍼텍스트란? <a id="2.-&#xD558;&#xC774;&#xD37C;&#xD14D;&#xC2A4;&#xD2B8;&#xB780;?"></a>

* 하이퍼링를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트 
* **기존의 책과 같은 선형적인 텍스트**가 아니라,  
   월드 와이드 웹\(WWW\)에서 사용되는 **하이퍼링크**와  
   **하이퍼텍스트**를 통해서 이어지는 **비선형적인 텍스트**가  
   신개념이라는 의미에서 만들어진 용어이다

  * 속된 말로 끝내주 텍스트..? 

* 중간에 걸쳐있는 것에 상관없이 비선형적으로 연결되어 있는 것   
* 하나의 문서내에서  어떤 용어나 참고 문헌을 곧바로 볼 수 있도록  링크로 연결해 놓을 수 있는데  이러한 문서를 하이퍼 텍스트라고 한다.

## 01. HTTP\[HyperText Transfer Protocol\] <a id="01.-HTTP[HyperText-Transfer-Protocol]"></a>

### 1. 정의 <a id="1.-&#xC815;&#xC758;"></a>

* W3 상에서 정보를 주고받을 수 있는 프로토콜
* HTML과 같은 하이퍼미디어 문서를 전송하기위한 애플리케이션 레이어\(응용계층\) 프로토콜
* HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜 즉, 한 문서를 받아오면 그 문서에 있는 모든 파일들을, 즉 하위 문서들\(텍스트, 이미지, 비디오 etc..\)도 다 받아올 수 있다.  

### 2. 목적 <a id="2.-&#xBAA9;&#xC801;"></a>

* 웹 브라우저와 웹 서버간의 커뮤니케이션을위해 디자인되었지만, 다른 목적으로도 사용 가능  

### 3. 특징  <a id="3.-&#xD2B9;&#xC9D5;"></a>

* 무상태 프로토콜이다.  - 서버가 각 요청간에 어떠한 데이터\(상태\)도 유지 하지않음  - 동일한 연결 상에서 연속하여 전달된 두 개의 요청 사이에 연결고리가 없다. 
* 클라이언트가 요청을 생성하기 위한 연결을 연다음 응답을 받을때 까지 대기하는 전통적인 **클라이언트-서버 모델을 따릅니다**. - 클라이언트는 서비스를 요청하는 요청자 역할, 서버는 서비스를 제공해주는 제공자 역할. cf\)  Q. 서버는 왜 서버인가?? A. '제공자\(server\)'이기 때문에  cf\) 서버  - 클라이언트\(대상\)에게 네트워크\(통로\)를 통해 정보나 서비스를 제공\(목적\)하는  컴퓨터 시스템으로  컴퓨터 프로그램\(server program\) 또는 장치\(device\)를 의미\(위키피디아\)  
* 주로 HTML 문서를 주고받는 데에 쓰인다.  
* 주로 TCP\(전송계층, 4계\)를 사용하고  
  HTTP/3 부터는 UDP를 사용

   cf\) 통신 프로토콜\[통신 규약\] - 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 '양식'과 '규칙'의 체계



## 02. HTTP 기반 시스템의 구성 요소 <a id="03.-HTTP-&#xAE30;&#xBC18;-&#xC2DC;&#xC2A4;&#xD15C;&#xC758;-&#xAD6C;&#xC131;-&#xC694;&#xC18C;"></a>

* HTTP가 깔고 들어가는 규약이 굉장히 많음 -&gt; 모두 알아야 한

### 1 . HTTP 기반 시스템의 구성 요소

* HTTP는 클라이언트- 서버 프로토콜 
* 요청은 하나의 개체, 사용자 에이전트\(또는 이를 대신하는 프록시\)에 의해 전송되며, 대부분의 경우 사용자 에이전트는 브라우저, 그러나 무엇이든 될 수 있다. 
* \[클라이언트 - 서버 통신\]의 구조\[간략히\]

  1. 각각의 개별적인 요청\(request\)들이 서버로 전송
  2. 이 요청들이 게이트웨이 또는 프록시 등을 거쳐 서버로 전송
  3. 서버는 이 요청을 받아서, 다시 클라이언트에 응답\(response\)을 전송

     클라-----프록시-----프록시-----서버

  
  cf\) 프록시, 프록시 서버

  * 클라이언트가 자신을 통해서 다른 네트워크 서비스에  **간접적**으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램  

* HTTP는 대표적인 응용계층에 있는 프로토콜

cf\) 하이퍼 링크 - &gt; 하이퍼 미디어로 바뀐 이유

* 원래는 문서만 보여줬지만,  시간이 지날수록 문서가 아닌 동영상 등의 매체도 볼 수 있게 되었기 때문

cf\) 상위수준에서는 하위 수준의 구현단계를 볼 필요가 없다.  
-&gt; 굉장히 추상화가 잘 되어있는 것

cf\) HTTP는 문서 전송에, FTP는 파일 전송에 특화

## 03. HTTP 특징  <a id="04.-HTTP-&#xD2B9;&#xC9D5;"></a>

* 간단
  * 사람이 읽을 수 있도 간단하게 고안
* 확장 가능
  * , HTTP 헤더는 HTTP를 확장하고 실험하기 쉽게 만들어주었습니다.
* 상태가 없지만 세션은 있다.
  * 상태가 없다\(Stateless\) - 무상태 프로토콜 = 하나의 요청이 다른 요청과 연결고리가 없다. = 하나의 요청이 다른 요청에 영향을 주지 않는다. = 모든 사용자에게 동일한 요청이 일관적인 방식으로 날아오기를 기대한다. 
* cf\) 세션 : 서버가 저장하는 것 쿠키 : 클라이언트가 저장하는 것, 
  * ex. 로그인 시 인증정보를 브라우저와 서버가 각각 가지게 됨 -&gt; 클라이언트는 키를 갖고 있다. : 키=쿠키 서버는 사물함을 갖고 있다. : 세션 = 사물함 =&gt; 서버는 키를 받아서 맞는 사물함을 열어본다. 만약 맞으면 사물함 안에 있는 정보를 꺼내온다 ex. 내 메일. 내 블로그 etc....

cf2\) 쿠키-세션 기반 인증의 단점

* 사용자 수가 많아지면 힘들어짐
* 사물함이 많아지면 서버가 관리하기 힘들어짐 =&gt; 요즘에는 다른 방식을 사용하기도 함
* HTTP의 핵심은 상태가 없는 것이지만, HTTP쿠키는 상태가 있는 세션을 만들도록 해준다.

## 05. HTTP로 제어할 수 있는 것 <a id="05.-HTTP&#xB85C;-&#xC81C;&#xC5B4;&#xD560;-&#xC218;-&#xC788;&#xB294;-&#xAC83;"></a>

* 캐시
  * - 정의 :  컴퓨터 과학에서 **데이터나 값을 미리 복사해 놓는 임시 장소**를 가리킨다. 
  * HTTP로 문서가 캐시되는 방식을 제어 가능 ex\) 같은 요청을 반복했을 때 앞단에 있는 캐시 서버가 서버 대신 응답을 해서 서버의 부담을 완화 
* 인증
  * HTTP **쿠키**를 사용해 특정 세션 설정하여 이루어질 수 있다.
* 세션 ex. 세션 인증 받은 사용자와 세션 인증 안받은 사용자의 요청 결과가 다르다.

## 06. HTTP 기본 흐름 방식 - 굉장히 중요, 면접 단골 문제 <a id="06.-HTTP-&#xAE30;&#xBCF8;-&#xD750;&#xB984;-&#xBC29;&#xC2DD;---&#xAD49;&#xC7A5;&#xD788;-&#xC911;&#xC694;,-&#xBA74;&#xC811;-&#xB2E8;&#xACE8;-&#xBB38;&#xC81C;"></a>

1. 단계 : TCP 연결을 연다.

* TCP 연결 역할 : 요청을 보내거나\(혹은 여러개의 요청\) 응답을 받는데 사용
* 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 서버에 대한 여러 TCP 연결을 열 수 있다.  

1. 단계 : HTTP 메세지를 전송\(request\)

* HTTP 메세지\(HTTP/2 이전의\)는 사람이 읽을 수 있는 것이 있음
* HTTP/2 에서는 다음의 메세지가 프레임 속으로 캡슐화되어 직접 읽는것은 불가능해졌지만, 원칙은 동일 - 요청의 예시
  * ```text
    GET(단순 요청) /(제일 첫번째를 요청)  HTTP/1.1 (버전)
    -> 즉, developer.mozilla.org 의 제일 첫번째거를 불러오는것
    Host: developer.mozilla.org
    Accept-Language: fr
    ```

1. 단계 서버에 의해 전송된 응답을 읽어들임\(response\)

* 응답의 예시
  * ```text
    HTTP/1.1 200 OK // 정상적으로 잘 요청했다는 의미
    Date: Sat, 09 Oct 2010 14:28:02 GMT // 응답을 반환한 시간
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    // 내가 요청한 문서가 마지막을 수정된 날짜

    // 지금부터는 해더
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769 // 반환될 문서의 길이
    Content-Type: text/html // 반환될 문서의 타입 
    // 한 칸 띄어져 있고, 이후 출력될 문서가 나옴  
    <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
    ```

1. 단계 연결을 닫거나 다른 요청들을 위해 재사용

* HTTP 파이프 라이닝이 활성화되면, 첫 번째 응답 완전히 수신할 때까지 기다리지 않고, 여러 요청을 보낼 수 있다.
* 최근에는 HTTP/2를 쓰기도 함

cf\)  
 HTTP가 노는 계층 바로 밑의 계층 - 전송계층\(or 전송층\)

* 전송계층에서의 프로토콜  
  : TCP 와 UDP가 존재

  1. TCP : 느린대신 확실, 순서가 보장됨

  2. UDP : 빠른 대신 확실하지 않음, 순서가 보장되지 않음

## 07 . HTTP 헤더 <a id="07-.-HTTP-&#xD5E4;&#xB354;"></a>

* 헤더의 정의
  * - 저장되거나 전송되는 데이터 블록의 맨앞에 위치한 **보충** [**데이터**](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0)**.**

  * - 본 문서 외의 기타적인 값들

  * - 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를  
     전송할 수 있도록 해줌

  * - 알아두어야 한다 : **적어도 해더를 읽고 이해할 수는 있어야 한다.**  
* 헤더는 요청에도 있고, 응답에도 있다. ex. cookie,  
* Context에 따른 헤더의 그룹핑 
  * -General header  
     : 요청과 응답 모두에 적용,  
     그러나 바디에서 최종적으로 전송되는 데이터와는  
     관련이 없는 헤더

  * - Request header  
    : 패치될 리소스나 클라이언트 자체에 대한  
     자세한 정보를 포함하는 해더

  * - Response header  
     : 위치 또는 서버 자체에 대한 정보\(ex. 이름, 버전\)과 같이  
     **응답에 대한 부가적인 정보**를 갖는 헤더

  * - Entity header 
    *  : 컨텐츠 길이나 MIME 타입과 같이 **엔티티 바디에 대한**  
       **자세한 정보를 포함**하는 헤더

    *  cf\) 엔티티  
       : 실체, 객체, 개체

    *  cf2\) MIME Type

       - 클라이언트에게 전송된 문서의 다양성을  
       알려주기 위한 메커니즘

       - 전자우편의 데이터 형식을 정의한 표준 포맷  
  
* **기능**에 따른 헤더의 종류 - 많이 사용되는 것 중심으로

  **1. 인증**

  * - Authorization  
     : 서버와 함께 유저 에이전트를 인증하기 위한 자격 증명을 포함

    \*\*\*\*

  **2. 캐싱**  


  *  Age  
     : 객체가 프록시 캐시에 있엇던 초 단위의 시간.

 

  * Cache-Control  
     : 요청과 응답 모두에서의 캐싱 메커니즘을  
     명시하는 지시문

    cf\) 캐싱 메커니즘????  

  *  Expires  
     : 응답이 만료되었다고 고려되는 날짜/시간

  *  Pragma  : 요청-응답 체인을 따라 어디든 다양한 영향을 줄 수 있는  구현관련 헤더,

      3 .쿠키

나머지들은  
 [https://developer.mozilla.org/ko/docs/Web/HTTP/Headers](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers) 참고

## 08. HTTP 요청 메소드 <a id="08.-HTTP-&#xC694;&#xCCAD;-&#xBA54;&#xC18C;&#xB4DC;"></a>

* 의미 : HTTP가 요청할 수 있는 메소드  
* 주로 사용하는 5가지 메소드 
  * **GET**  


    * - 특정 리소스의 표시를 요청 ex. 리소스 : 문서 
    * - GET을 사용하는 요청은 **오직 데이터를 받기만 한다**.  ex.  www.naver.com을 들어가는 과정 자체가  GET 메소드를 사용한 HTTP 요청  - 즉, 일반적인 문서를 볼때 사용됨 
    *  **- 주의 : POST와 유사하게 GET 도 어떤 값을 보내서 요청할 수 있다.**

  *  **POST**  


    *  특정 리소스에 **엔티티를 제출**할 때 사용됨  
      cf\) 엔티티  
       - 데이터의 집합  
       - 저장되고, 관리되어야 하는 데이터  
       - 유.무형의 대상을 가리킴

       - 즉, 값을 넣어줄 때 사용  

    * ex\)  
       로그인 시, 사용자 아이디와 비밀번호를 넣어 **보낸다**.  
       이때 로그인하는 과정은 POST  
       Q.왜?  
       A. 아이디와 비밀번호가 요청에 같이 실려서  
       서버에 제출되기 때문

    *  - 즉, 일반적인 문서를 볼 때 말고,  
       **값을 담아서 요청**을 해야하는 상황이 올때 사용됨

    *  Q. 그러면 POST와 GET의 차이는 무엇일까???\*\*  
       A. GET은 간단한 값들을 날려서 요청할 때,  
       주소에 담아 날려보낼 수 있다.  
       반면에 POST는  
       주소에 날려보내기보다 HTTP 바디, 요청 바디에 날려보낸다.  
       즉, 민감한 정보들을 주소로부터 숨긴다.

       **하지만 위 이유 말고 본질적인 이유 존재**  
 

      * =&gt; GET메소드는 문서를 **받는것, 읽는 것**에 중점을 두며,  
         반면에  
         POST는 **데이터를 보내는 것\(데이터 전송\)**에 중점을 둔다.  
         그래서, **응답이 오는것은 신경쓰지 않음**  

  * **PUT**  
 

    * post와 비슷 
    *  그러나 post보다 **수정**이라는 행위에 좀 더 중점을 둠  
    * ex. 위키를 수정하고 \[ok\]버튼을 누르면, put메소드가 사용됨

       - 리소스의 **전체 교체**, 리소스내 모든 필드 필요

  * **DELETE**  
     - post와 비슷하지만 삭제할 때 사용

    \*\*\*\*

  * **PATCH** - PUT 메소드와 비슷, 그러나 - 리소스의 **부분 교체**, 리소스 내 일부 필드 필요

## 09. HTTP 상태 응답 코드\(= 응답 상태 코드\) <a id="09.-HTTP-&#xC0C1;&#xD0DC;-&#xC751;&#xB2F5;-&#xCF54;&#xB4DC;(=-&#xC751;&#xB2F5;-&#xC0C1;&#xD0DC;-&#xCF54;&#xB4DC;)"></a>

* 클라이언트가 요청한 결과를 알려주는 코드  
* 응답 상태 코드 범주 1XX : 정보 - 의미 : 전송 프로토콜 수준의 정보 교환, 정보에 대한 응답 - 거의 볼일 없다 2XX : 성공 - 의미 : 클라이언트 요청이 성공적으로 수행됨을 의미 3XX : 재전송 - 클라이언트는 요청을 완료하기 위해 **추가적인 행동**을 취해야 함을 의미 4XX : 클라이언트 오류 : 클라이언트의 잘못된 요청 5XX : 서버 오류 : 서버쪽 오류로 인한 상태코드  
* 2XX 응답 상태 코드  
  1. 200\(“OK”\)  
   - 요청한 어떤 액션이었든 성공적으로 수행했음을 나타내는 데 사용됨  
   - 응답 바디가 포함되는 코드  
   - 응답 바디에 에러를 전송하는 데 사용되서는 안된다.  
   - PUT, POST, GET, HEAD 등의 요청에 대한 응답으로 사용됨

  2. 201\(“created”\)  
   - 성공적으로 리소스 생성했을 때 사용  
   - POST 요청이나, PUT 요청에 대한 응답으로 많이 사용됨  
   - 즉, 정상적으로 서버에 내 요청에 대한 자원을 등록했다는 의미

  3. 202\(“Accept”\)  
  - 비동기 처리가 성공적으로 시작되었음을 알릴 때 사용  
   - 유효한 요청이었지만, 최종 처리까지는  
   문제가 생길 수도 있다는 것을  
   클라이언트에게 알려줌  
   - 처리시간이 오래 걸리는 액션에 사용됨

  4. 204\(“No Content”\)  
   - 응답 바디에 의도적으로 아무것도 포함되지 않을 때 사용  
   - 보통 PUT,POST,DELETE요청에 대한 응답으로 이용

* 3XX 응답 상태 코드 1. 301\(“Moved Permanetly”\) - 요청된 리소스의 URL이 영구적으로 변화되었을 때 사용됨 - 새로운 URL은 응답 안에 주어진다.
* 4XX 응답 상태 코드  
  1. 400\[Bad Requset\]  
   - 일반적인 요청 실패에 사용  
   - 유효하지 않은 구문에 의해  
   요청을 이해하지 못할 때 사용됨

   2. 401\(Unautorized\)  
   - 클라이언트가 적절한 인증 없이 보호된 리소스를 사용하려 할 때 발생  
   - 인증을 잘못하거나, 아예 인증하지 못할 경우 발생

   3. 403\(“Forbidden”\)  
   - 인증상태에 상관없이 액세스를 금지할 때 사용 - 자원에 대한 권한이 없다  
   - 클라이언트의 요청은 정상이지만, 요청에 응하지 않을 경우 발생  
   - 즉, 인증에 문제가 있어서 발생하는 것이 아님

  \* 401 VS 403  
   - 401 : **인증** 여부에 따라 바뀜  
   - 403 : 인증 여부에 상관없이 **권한**이 없기 때문에 금지

   4. 404\(“Not Found”\)  
   - 클라이언트가 요청한 URI에 해당하는 리소스가  
   존재하지 않을 때 사용

  5. 405\(“Method Not Allowed”\)  
   - 클라이언트가 사용한 HTTP 메소드가 **지원되지 않을 때 사용**  
   ex\) 읽기 전용 리소스는 GET 과 HEAD 메소드만 지원,  
   ex2\) 내 리소스에 DELETE 메소드를 허용하지 않았다.

  6. 415\(“Unsupported Media Type”\)  
   - 요청헤더에 기술된 클라이언트가 제공한 미디어 타입을  
   처리하지 못할 때 발생

* 5XX 응답 상태 코드 - 다시 설명 요구  
  1. 500\(Internal Server Error\)  
   - 서버가 오류난 상태  
   ex. 예외 처리 못할때

  2. 502\(Bad Gateway\)  
   - 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용

  3. 503\(Service unavailable\)  
  - 서버공사 중,서버점검 중일 때

  4. 504\(Gateway Timeout\)  
  - 게이트웨이 타임아웃됨

  5. 505\(HTTP Version Not Supported\)  
  - HTTP 버전이 맞지 않는 곳에서 요청을 함

