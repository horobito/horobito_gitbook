# 4. 리포지터리와 모델 구현

## 01. JPA를 이용한 리포지터리 구현

* 자바 ORM의 표준인 JPA 를 이용, 리포지터리와 애그리거트를 구현하는 방법에 대해 알아본다. 

### 1 . 모듈 위치

* 위치
  * 리포지터리 인테페이스
    * 도메인 영역 
  * 리포지터리를 구현한 클래스
    * 인프라 스트럭쳐 영

### 2. 리포지터리 기본 기능 구현 

* 리포지터리의 기본 기능
  * Id 로 애그리거트 조회
    * ```java
      public Order findById(OrderNo no);
      ```
  * 애그리거트 저장 
    * ```java
      public void save(Order order);
      ```
* 리포지터리 인터페이스는 **애그리거트 루트\(루트 엔티\)**를 기준으로 작성   
* JPA의 EntityManager를 이용한  리포지터리 구현 클래스에서 조회 및 저장 메소드 구현
  * ```java
    @Repository
    public class JpaOrderRepository implements OrderRepository(){

        @Override
        public Order findById(){
            return entityManager.find(Order.class, id);
        }
    
        @Override
        public void save(Order order){
            entityManager.persist(order);
        }

    }
    ```



* @Transactional

  * 트렌잭션 범위에서 변경한 데이터를  자동으로  DB에 반영하기 위한 어노테이션  
  * 예시
    * ```java
      public class ~~~Service{


         @Transcational
         public void change~~~~(){
   
         }
      }
      ```
    * 여기서 해당 메소드는  스프링 프레임워크의 트랜젝션 관리 기능을 통해 트랜젝션 범위에서 실행  
    * 메소드 실행이 끝나면 트랜잭션을 커밋하는데, 이때 JPA는 트랜잭션 범위에서 변경된 객체의 데이터를 DB에 반영하기 위해 UPDATE 쿼리를 실행 



* Id 가 아닌 다른 조건으로 애그리거트를 조회하는 경우, findBy 뒤에 조건 대상이 되는 프로퍼티 이름을 붙임 



* 리포지터리에서 삭제 기능을 위한 메소드
  * ```java
    public interface OrderRepository{
        public void delete(Order order)
    }
    ```
  * 이는 구현 클래스에서 **Entity Manager**의 **remove\(\) 메소드**를 이용해서 삭제 기능을 구현한다. 
    * ```java
      @Override
      public void remove(Order order){
          entityManager.remove(order);
      }
      ```
  * 참고
    * 여러가지 이유로 인해 \(ex. 데이터의 일정 기간 보\) 데이터를 삭제하는 것 보다는, 삭제 플래그를 이용해서 데이터의 화면 출력 여부를 결정하는 방식으로 구현하는 것이 좋다. 



## 02. 매핑 구현

### 1 . 엔티티와 밸류 기본 매핑 구현

* 애그리거트와 JPA 매핑을 위한 기본 규칙

  * 애그리거트 루트는 앤티티이므로, @Entity로 매핑 설정 
  * 한 테이블에 엔티티와 밸류 데이터가 같이 있다면

    * 밸류는 @Embeddable 로 설정
    * 엔티티의  밸류 타입의 프로퍼티는 @Embedded 로 설정
    * 예시
      * ```text
        public class A{

          @Embedded
          public B b;
        }

        @Embeddable
        public class B{
           @Embeddable
           public C c;

        }

        @Embeddable
        public class C{

        }
        ```
    * JPA2부터  @Embeddable은 중첩을 허용 

* @AttributeOverride 
  * 사용 목적
    * @Embeddable 타입에 설정한 칼럼 이름\(\)과  
      실제 칼럼 이름이 다르므로,  
      해당 어노테이션을 이용해서 매핑할 칼럼 이름을 변  
  * 예시1
    * ```text
      @Entity
      public class Order{
         @Embedded
         public Orderer orderer

      }




      @Entity
      @Embeddable
      public class Orderer(){
          ...
          @Embedded
          @AttributeOverrides(
             @AttributeOverride(
             // MmeberId의 필드 이름 "id"
                name = "id",
          
             //memberId 프로퍼티와 매핑되는 칼럼이름이
             // orderer_id
             // @AttributeOverrides 를 붙이는 이유
             // @Embeddable 타입에 설정한 칼럼 이름인
             // member_id 와
             // 실제 칼럼 이름인
             // orderer_id
             //  다르기 때문   
             // 매핑할 때 해당 어노테이션 이용하여
             // 매핑할 칼럼 이름을 변
                column = @Column(nane = "orderer_id)
             )
          )
          public MemberId memberId
      }


      @Embeddable
      public class MemberId{
         @Column(name='member_id')
         private String id

      }
      ```
  * 예시2
    * ```text
      @Embeddable
      public class ShippingInfo{
         @Embedded
         @AttributeOverrides{
            @AttributeOverride(
              name = "zipcode,
              column = @Column(name = "shipping_zipcode)
            )
      
            @AttributeOverride(
              name = "address1",
              column = @Column(name = "shipping_addr1")
            )
            @AttributeOverride .... 
   
         }
      }

      @Embeddable
      public class Address{

        @Column(name = "Shipping_message)
        public String zipCode;
  
        @Column(name = ~~~)
        public String address1;
  
        @Column(name = ~~~)
        public String address2;
      }

      ```

### 2. 기본 생성자

* 엔티티와 벨류의 생성자는 객체를 생성할 때  필요한 것들을 전달받음 
* 이때 이들이 불변타입이라면,  
  생성 시점에 필요한 값들을 모두 전달받으므로,  
  Set 메소드를 제공하지 않음 

  * 즉, 기본 생성자를 추가할 필요가 없다는 것을 의미  

* 그러나 JPA의 @Entity와 @Embeddable 로  클래스를 매핑하려면 \[기본 생성자\]를 제공해야 한다. 
  * Hibernate 와 같은 JPA 프로바이더는  DB에서 데이터를 읽어와 매핑된 객체를 생성할 때, 기본 생성자를 사용해서 객체를 생성하는 기술적 제약이 있기 때문  
  * 따라서 1  .기본 생성자를 추가한다.

    * 이때 다른 코드에서 기본생성자를 사용하여, 온전하지 못한 객체를 만들지 못하게 하기 위해 protected 접근 제한자를 설정한다. 

  * 또는 @NoArgsConstructor 어노테이션을 붙인다. 

  

### 3. 필드 접근 방식 사용

* JPA는 \[필드\] 와 \[메소드\]의 두 가지 방식으로 매핑을 처리할 수 있다. 
* \[메소드\] 방식 사용하려면, properties 를 위한 get/set 메소드를 구현해야 한다
  * 그러나 이렇게 공개 get/set 메소드를 구현하면, 도메인의 의도가 사라지고, 객체가 아닌, 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
  * 따라서 외부에 set 메소드 대신, 의도가 잘 드러나는 메소드를 대신 제공해야 한다.  
* 엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면, JPA 매핑 처리를 , property 방식이 아닌, **필드 방식**으로 선택해서, 불필요한 get/set 메소드를 구현하지 말아야 한다.  
* cf\) 필드 vs 프로퍼티
  * 덕구라는 객체는 name과 old라는 속성을 가지고 있는 객체이고,

    java bean 정의에 의한 getter\(\) 와 setter\(\) 메소드로 실제 값\(필드\)

    \(예: 이름 = 덕구, 나이 =12살\)에 접근할 수가 있습니다.

  * 출처 : [https://okky.kr/article/455024](https://okky.kr/article/455024)  
* cf2\) 
  * JPA 구현체인 hibernate 는 @Access 를 이용하여, 명시적으로 접근 방식을 지정하지 않으면, @Id나 @EmbeddedIDd 가 어디에 위치했느냐에 따라 접근방식을 결정한다.
  * @Id나 @EmbeddedIDd  가 필드에 위치하면, 필드 접근 방식을 선택하고, get 메소드에 위치하면 메소드 접근 방식을 선택한다.  

4. Attribute Converter 를 이용한 밸류 매핑 처리

* int, long, String, LocalData와 같은 타입은  DB 테이블의 한 개 칼럼과 매핑된다. 
* 이와 비슷하게, 밸류 타입의 프로퍼티를  한 개의 칼럼에 매핑해야 할때도 있다.
  * ex\)  
     \[값\] 과 \[단위\] 의 두 property를 갖고 있는 \[Length\]는  
    한 개의 칼럼에 1000mm 와 같은 형식으로 저장할 수 있다. 

    * ```java
      public class Length{
          private int value;
          private String unit;
      }
      ```
    * 

  * 이렇게 두 개 이상의 property를 가진 밸류 타입을 한 개 column에 매핑해야 할 경우, @Embedded로는 처리할 수 없다. 
  * JPA 2.1 이상부터는 AttributeConverter를 사용하여 변환을 처리할 수 있다.
    * AttributeConverter

      * JPA 2.1 에 추가된 인터페이스
      * 밸류 타입과 칼럼 데이터 간의 변환 처리를 위한 기능을 정의
      * ```java
        package javax.persistence;

        public interface AttributeConverter<X,Y>{
            public Y convertToDatabaseColumn (X attribute);
            public X convertToEntityAttribute (Y dbData);
        }
        ```
      * X : 밸류 타입
      * Y : DB 타입 
      * convertToDatabaseColumn\(\)
        * 밸류 타입을 DB 칼럼 값으로 변환하는 기능 
      * convertToEntityAttribute\(\)
        * DB 칼럼 값을 밸류로 변환하는 기능 

    * ex\) \[Money\] 밸류 타입을 위한 Attribute Converter 구현



      * ```java
        @Converter(autoApply=true)
        public class MoneyConverter implements AttributeConverter<Money, Integer>{
    
            @Override
            public Integer convertToDatabaseColumn(Money money){
                if(money = null){
                    return null;
                }else{
                    return money.getValue;
                }
            }
    
            @Override
            public Money convertToEntityAttribute(Integer value){
                if(value == null){
                    return value;
                }else{
                    return new Money(value);
                }
            }
        }
        ```
      * AttributeConverter 인터페이스를 구현한 클래스는 @Convert 어노테이션을 적용한다. 
      * autoApply 속성값을 true 로 지정한 것은 모델에 출연하는 모든 Money 타입의 property에 대해 MoneyConverter 를 자동으로 적용하겠다는 의미
        * ```java
          @Column(name = "total_amount)
          private Money totalAmount; 
          // MoneyConverter를 자동 적용해서  변환
          ```
        * false 인경우, property 값을 변환할 때 사용할 converter를 직접 지정할 수 있다.
        * ```java
          @Convert(converter = MoneyConverter.class)
          private Money totalAmount;
          ```

### 4. 밸류 컬렉션1 : 별도 테이블 메핑

* Order 엔티티는 1개 이상의 OrderLine을 가질 수 있다.

  * 이 경우, List 타입을 이용하여 OrderLine 타입의 collection을  property로 갖게 된다.
  * ```java
    public class Order{
        private List<OrderLine> orderLines;
    }
    ```
  * 이때 밸류 타입의 collection은 별도의 테이블에 보관한다.
    * PURCHASE \_ ORDER 
      * order\_number Varchar\(30\)
    * ORDER\_LINE
      * order\_number varchar\(30\)
      * line\_idx integer\(30\)
      * product\_Id varchar\(30\)
      * price integer\(30\)
      * quantity integer\(30\)

  
  * 이때 밸류 컬렉션을 저장하는 Order\_Line 테이블은,  
    외부키를 이용해서, 엔티티에 해당하는 PURCHASE ORDER 테이블을 참조한다. 

    * 이 외부키는 컬렉션이 속할 엔티티를 의미한다. 
    * 또한 컬렉션은 인텍스 값이 필요하므로, ORDER\_LINE 테이블에는 인덱스 값을 저장하기 위한 칼럼\(line\_idx\)도 존재한다.  

 

* 밸류 컬렉션을 별도의 테이블로 매핑할 때는 @ElementCollection 과  @CollectionTable 을 함께 사용한다. 
  * ex\) 
  * ```java
    @Entity
    @Table
    public class Order{
        ...
        @ElementCollection
        @CollectionTable(
            name = "order_line",
            joinColumn = @JoinColumn(name = "order_number")
        )
        @OrderColumn(name = "line_idx")
        private List<OrderLine> orderLines;
        ...
    }

    @Embeddable 
    public class OrderLine{
        @Embedded
        private ProductId productId
    
        @Column 
        .....
    }
    ```
  * 이때 OrderLine에는 List의 인텍스 값을 

### 5. 밸류 컬렉션 2 : 한 개 칼럼 매핑

### 6. 밸류를 이용한 아이디 매핑

### 7. 별도 테이블에 저장하는 벨류 매핑

### 8. 밸류 컬렉션을 @Entity로 매핑하기

### 9. ID 참조와 조인 테이블을 이용한 단방향 M-N 매



## 03. 애그리거트 로딩 전략

## 04. 애그리거트의 영속성 전파

## 05. 식별자 생성 기

