# 11. CQRS

## 01. 단일 모델의 단점

### 1 . 주문 내역 조회로 보는 단일 모델의 단점 

* 주문 내역 조회 

  * 여러 애그리거트에서 데이터를 가져와야 함 



  ![](../../.gitbook/assets/image%20%2849%29.png)



* 조회 화면의 특성상, 조회 속도가 빠를수록 좋은데, 여러 애그리거트에서 데이터를 가져와야 할 경우  구현 방법을 고민해봐야 한다. 
  * 만약 ID를 이용해서 애그리거트를 참조하는 방식의 경우 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다. 
    * 이는 한번의 select로 조회 화면이 필요한 데이터를  읽어 올 수 없어 조회 속도에 문제가 생길 수 있다. 
  * ID 참조가 아닌 직접 참조 방식으로 연결해도 , 고민거리가 생긴다.
    * 조회 화면의 특성에 따라 같은 연관도  즉시 로딩이나 지연 로딩으로 처리해야 하기 때문 



* 위와 같은 문제의 발생 원인 
  * 시스템의 상태를 변경할 때와 조회할 때  \[단일 도메인 모델\]을 사용하기 때문 
  * 객체지향 시 주로 사용하는 ORM 기법은  도메인 상태의 변경을 구현하는데는 적합
  * 그러 여러 애그리거트에서 데이터를 가져와 출력하는 기능을  구현하기넹는 고려할 것이 많아서 , 구현을 복잡하게 만드는  원인이 된다.  
* \[상태 변경을 위한 모델과 조회를 위한 모델의 분리\]
  * 위의 문제들을 해결할 수 있는 방법 

## 02. CQRS 

### 0. CQRS\[Command Query Responsibility Segregation\]

* 시스템이 제공하는 기능
  * 1 . 상태를 변경하는 기능 
  * 2 . 상태 정보를 조회하는 기능 





* 도메인 모델 관점에서의 상태 변경 기능 
  * 주로 한 애그리거트의 상태를 변경 
  * ex\)

    * 주문 취소 기능과 배송지 정보 변경 기능은  한 개의 Order 애그리거트를 변경 

  
* 도메인 모델 관점에서의 조회 기능 
  * 한 애그리거트의 데이터를 조회할 수도 있지만, 두 개 이상의 애그리거트에서 데이터를  조회할 수도 잇다. 
    * ex\)
      * 앞에서의 주문 상세 조회 기능 





* 이처럼, 상태 변경 기능과 상태를 조회하는 범위가  정확하게 일치하지 않기 때문에  단일 모델로 두 종류의 기능을 구현하면  모델이 불필요하게 복잡해진다. 
  * 이때 사용하는 것이 바로 CQRS이다.  
  * CQRS\[Command Query Responsibility Segregation\]
    * 상태를 변경하는 명령\[Command\] 을 위한 모델과 
    * 상태를 제공하는 조회\[Query\]를 위한 모델을  서로 분리하는 패턴  

![](../../.gitbook/assets/image%20%2833%29.png)





* CQRS는 복잡한 도메인 모델에 합 

  * 도메인이 복잡할수록  명령 기능과 조회 기능이 다루는 데이터 범위에 차이 발생 
  * 이 두 모델을 단일 모델로 처리 시 , 조회 기능의 로딩 속도를 위해, 모델 구현이 필요 이상으로  복잡해지는 문제가 발생 
  * 이때 CQRS를 적용하면 조회 모델을 별도로 만들기 때문에  조회 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.  

* CQRS를 사용 시 각 모델에 맞는 구현 기술을 선택할 수 있다. 
  * 예시
    * 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현 
    * 조회 모델은 DB 테이블에서 SQL 로 데이터를 조회할 때 좋은 MyBatis를 사용해서 구현 가능 

![](../../.gitbook/assets/image%20%2825%29.png)

* 위 그림에서는   
  조회 모델에는 응용 서비스가 존재하지 않는다. 

  * 단순히 데이터를 읽어와 조회하는 기능은  응용 로직이 복잡하지 않기 때문에 컨트롤러에서 바로 DAO를 무방하기 때문 
  * 물론, 데이터를 표현 영역에 전달하는 과정에서  몇 가지 로직이 필요하다면 응용 서비스를 두고  로직을 구현하면 된다.    

* 명령 모델과 조회 모델의 설계 예시
  * 상태 변경을 위한 명령 모델은  객체를 기반으로 한 도메인 델을 이용해서 구현한다.  
  * 반면 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를  담고 있는 데이터 타입을 이용한다.  
  * 두 모델 모두 주문과 관련되어 있지만, 
    * 명령  모델은 상태를 변경하는 도메인 로직을 수행하는데 , 초점을 맞춰 설계했고,
    * 조회 모델은 화면에 보여줄 데이터를 조회하는데 초점을 맞춰 설계했다. 

![](../../.gitbook/assets/image%20%2830%29.png)

* 명 모델과 조회 모델이 같은 구현 기술을 사용할 수도 있다.
  * ex\) 5장의 \[조회 전용 기능 구현\] 절에서 , JPQL 을 이용한 동적 인스턴스 생성과, 하이버네이트의 @Subselect를 이용한 방법 중 동적 인스턴스로 사용할 클래스와 @Subselect를 적용한 클래스가  조회 모델에 해당한다.   



* 명령 모델과 조회 모델이 서로 다른 데이터 저장소를  사용할 수도 있다.
  * 예시
    * 명령 모델은 트랜젝션을 지원해주는 RDBMS를 사용하고, 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을  사용할 수 있을 것이다.  
    * 두 데이터 자장소 간의 데이터 동기화는  10장에서 배운 이벤트를 활용해서 처리한다. 
      * 명령 모델에서 상태를 변경하면  이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서  변경 내역을 반영하면 된다.  

![](../../.gitbook/assets/image%20%2846%29.png)

*  * 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우, 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다.
    * 명령 모델에서 데이터가 바뀌자마자  



### 1 . 웹과 CQRS



### 2. CQRS 장.단점 

