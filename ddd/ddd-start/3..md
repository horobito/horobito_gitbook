# 3. 애그리거트

목차

1. 애그리거트
2. 애그리거트 루트
   1. 도메인 규칙과 일관성
   2. 애그리거트 루트의 기능 구현
   3. 트랜젝션 범위
3. 리포지터리와 애그리거트
4. ID를 이용한 애그리거트 참조
   1. ID를 이용한 참조와 조회 성능
5. 애그리거트 간 집합 연관
6. 애그리거트를 팩토리로 사용하기





## 01. 애그리거트

### 1 . 애그리거트

* **애그리거트 정의**
  * 관련된 객체를 하나의 군으로 묶어준 것 



* **애그리거트 특징**

  * 애그리거트에 속한 객체는  유사하거나, 또는 동일한 라이프사이클을 갖는다. 
    * 즉, 애그리거트에 속한 구성요소 대부분은 함께 생성되고, 함께 제거  
  * 애그리거트는 경계를 같는다.

    * 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
      * 애그리거트는 독립된 객체 군  
    * 각 애그리거트는 자기 자신만 관리할 뿐, 다른 애그리거트를 관리하지 않는다.  

  * 도메인 규칙을 제대로 이해할수록,  
    실제 애그리거트의 크기는 줄어든다.  

* **경계의 설정 시 기본이 되는 것**
  * 도메인규칙과 요구사항 
  * 따라서 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다. 
  * 함께 변경되는 빈도가 높은 객체들은 한 애그리거트에 속할 가능성이 높다. 
* **주의점**
  * \[A가 B를 갖는다\]라 해석할 수 있는 요구사항이 있더라도, 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하지는 않음 ex\) 상품 - 리뷰 
    * 라이프사이클이 다르다\(함께 생성되거나 변경되지 않음\)
    * 변경 주체도 다르다. \(상품 담당자 - 고\) 



## 02. 애그리거트 루트

* 루트 엔티\[애그리거트 루트\]

  * 에그리거트 전체를 관리하는 주체

  * 애그리거트에 속한 모든 객체가 일관된 상태를 갖도록 유지시켜 준다.  
  * 애그리거트에 속한 객체들은 루트 앤티티에 직접 또는 간접적으로 속한다. 

### 1 . 도메인 규칙과 일관성

* 애그리거트 루트의 핵심 역할

  * 애그리거트의 일관성이 깨지지 않도록 하는 것  
  * 따라서 애그리거트가 제공해야 하는 도메인 기능을  
    애그리거트 루트가 구현 

    * 이때 이 메소드는 애그리거트에 속한 객체의  일관성이 깨지지 않도록 구현해야 한다. 

* 주의사항
  * 애그리거트 루트가 아닌 객체가 애그리거트에 속한 객체를 직접 변경하면 안됨
    * 루트가 강제하는 규칙을 적용할 수 없어, 모델의 일관성을 깨버리는 원인이 된다.  ex\)
    * ```text
      ShippingInfo si = order.getShippingInfo();
      si.setAddress(newAddress);
      // 업무 규칙을 무시하고,
      // DB 테이블에서 직접 데이터를 수정하는 결과를 만듬 
      ```
    * 일관성을 지키기 위해 서비스층에 구현할 경우, 동일 검사 로직을 여러 서비스층에 중복 구현하게 되어, 상황 악화됨 



* 중복 방지 및 애그리거트 루트 통한 도메인 로직 구현을 위한 필수적인 두 가지
  * 1 . 단순히 필드 변경하는 set 메소드를 public 범위로 만들지 않는다.
  * 2 . 벨류 타입은 불변으로 한다.  
* \[단순히 필드 변경하는 set 메소드를 public 범위로 만들지 않는다.\]
  * 지키지 않을 경우 문제점
    * 도메인의 의미,의도 표현 못하고, 도메인 로직이 응용 또는 표현영역으로 분산 
    * -&gt; 도메인 로직의 분산으로 유지보수 시  분석 및 수정시간 증가  
  * 지킬 경우
    * 의미가 드러나는 메소드를 사용하므로,  
      비지니스 규칙의 이해가 높아
* \[벨류 타입은 불변으로 한다.\]
  * 지킬 경우
    * 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없게 된다. 
      * 따라서 애그리거트의 일관성이 깨질 가능성 감 
  * 벨류 값 변경하는 방법
    * 새로운 밸류 객체를 할당하는 것  
  * 밸류타입의 내부 상태 변경하려면 애그리거트 루트를 통해서만 가능하도록 한다. 

### 2. 애그리거트 루트의 기능 구현

* 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합하여 기능을 완성  
* 애그리거트 루트는 기능 실행을 위임하기도 한다. 
  * ex\) Order가 OrderLine을 별도 클래스로 분리한 후, 기능 실행을 위임
  * 이때 변경 기능을 패키지 또는 protected 범위로 한정하여 외부에서 실행할 수 없도록 한다
    * 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방

### 3. 트랜젝션 범위

* 트랜젝션 범위는 작을수록 좋다. 
  * 성능의 문제 때문 



* 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 
  * 의미

    * 한 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것 

  * 따르지 않을 경

    * 하나의 애그리거트가 다른 애그리거트를 관리하게 된다.
      * 독립성이 떨어짐, 결합도가 높아짐 
    * 트랜젝션 충돌 가능성 높아진다.  

  * 어쩔 수 없는 경우
    * **\[응용 서비스\]**에서 두 애그리거트를 수정하도록 구현해야 한다.  
* \[한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다\] 의 

## 03. 리포지터리와 애그리거트

* 리포지터리
  * 객체의 영속성을 처리 

  * 애그리거트 단위로 존재
    * 애그리거트는 개념상 한 개의 도메인 모델을 표현하므로  
  * 애그리거트 루트를 위한 리포지터리만 존재한다.  
* 리포지터리가 제공해야 하는 두 가지 필수 메소드

  * save
  * findById

  

* 애그리거트는 개념적으로 하나이므로, 리포지터리는 애그리거트 전체를 저장소에 영속화해야한다. 
  * 애그리거트 저장 시  애그리거트에 속한 모든 구성요소를 저장해야 한다.  
* 또한 애그리거트를 구하는 리포지터리 메소드는 완전한 애그리거트를 제공해야 한다.  
* 애그리거트 상태 변경시 모든 변경을 원자적으로 저장소에  반영해야 한다.  



## 04. ID를 이용한 애그리거트 참조

* 애그리거트의 관리 주체는 애그리거트 루트
  * 따라서 애그리거트가 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것  
* 애그리거트 루트를 필드로 직접 참조하는 것의 위험성

  * 편리함을 오용
    * 다른 애그리거트의 상태를 쉽게 변경하게 되어  
      애그리거트의 관리 범위가 자기 자신을 넘어서게 된다. 

    * 이 결과 의존 결합도를 높여 애그리거트의 변경을 어렵게 만든다.  
  * 성능 관련 고민
    * 
  * 확장의 어려움 

    * 부하 분산 위해 하위 도메인 별 시스템을 분리할 때, 서로 다른 DBMS를 사용할 가능성이 높아지는데, 이 경우 다른 애그리거트 루트를 참조하기 위해 단일 기술을 사용하는 것이 어려워진다. 

* ※ 해결방안 ※
  * \[ID를 이용해서 다른 애그리거트를 참조하는 것\]
    * 
  * ex\)

    ```text
    public class Order{

       private MemberId memberId; // 다른 애그리거트의 루트의 id로 참조 
    }
    ```

  * 장점
    * 

## 05. 애그리거트 간 집합 연관

## 06. 애그리거트를 팩토리로 사용하



