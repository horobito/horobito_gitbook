# 9. 도메인 모델과 BOUNDED CONTEXT

## 01 . 도메인 모델과 경계

### 1 . 도메인 모델과 경계

* 도메인 모델 만들 시 흔히 하는 실수
  * 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것
    * 하나의 도메인은 여러 하위 도메인으로 구분되기 때문에, 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 모든 하위 도메인에 맞지 않는 모델을 만들게 됨
    * EX\) \[상품\] 이라는 모델
      * 카탈로그에서의 상품, 재고 관리에서의 상품, 주문에서의 상품, 배송에서의 상품 모두 이름만 같을 뿐 실제로 의미하는 것은 다르다.
    * 또한 논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
      * ex\) 주문자
        * 회원도메인 : 회원
        * 주문 도메인 : 주문자
        * 배송 도메인 : 보내는 사람
* 하위 도메인마다 사용하는 용어가 다르기 때문에, 올바른 도메인 모델을 개발하려면, 하위 도메인마다 모델을 만들어야 한다.
  * 각 모델은 명시적으로 구분되는 경계를 가져서 , 섞이지 않도록 해야 한다.
    * 모델들이 섞이기 시작하면 , 모델의 의미도 약해지고, 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.
* 모델은 특정한 컨텍스트\[문맥\]하에서 완전한 의미를 갖는다.
  * 같은 제품이라도 카탈로그 컨텍슽와 재고 컨텍스트에서 의미가 서로 다르다.
  * 이렇게 구분되는 경계를 갖는 컨텍스트를 BOUNDED CONTEXT 라고 부른다.

## 02 .BOUNDED CONTEXT

### 1. BOUNDED CONTEXT 의 특징

* BOUNDED CONTEXT
  * 모델의 경계를결정한다.
  * 한 개의 BOUNDED CONTEXT 는 논리적으로 한 개의 모델을 갖는다.
  * BOUNDED CONTEXT 는 용어를 기준으로 구분한다.
    * ex\) 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 , 이 용어를 기준으로 컨텍스트를 분리할 수 ㅣㅇㅆ다.
  * BOUNDED CONTEXT 는 실제로 사용자에게 기능을 제공하는 물리적 시스템이다.
    * 도메인 모델은 이 BOUNDED CONTEXT 안에서 도메인을 구현한다.

### 2 . 조직 구조에 따른 BOUNDED CONTEXT

* BOUNDED CONTEXT 는 하위 도메인과 일대일 관계를 가지면 좋으나, 기업의 팀 조직 구조에 따라 결정되는 경우 그렇지 않게 된다.
  * 예시
    * 주문 하위 도메인이라도, 주문을 처리하는 팀과 결제 금액 계산 로직을 구현하는 팀이 따로 있다고 가정
      * 이 경우 주문 하위 도메인에 주문 BOUNDED CONTEXT 와 결제 금액 BOUNDED CONTEXT 가 존재하게 된다.
    * 규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다.
      * 소규모 쇼핑몰을 운영할 경우 한 개의 웹 애플리케이션으로 온라인 쇼핑을 서비스할 때,
        * 이 경우 하나의 시스템에서 회원, 카탈로그, 재고, 구매,

          결제와 관련된 기능을 제공한다.

          즉, 여러 하위 도메인을 한 개의 BOUNDED CONTEXT에서 구현하게 된다.
    * 아직 용어를 명확하게 하지 못해, 두 하위 도메인을 한 BOUNDED CONTEXT 에서 구현하기도 한다.

      * 카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 두 하위 도메인을 한 BOUNDED CONTEXT 에서 구현하기도 한다.

![](../../.gitbook/assets/image%20%2831%29.png)

### 3 . 여러 하위 도메인을 하나의 BOUNDED CONTEXT에서 구현 시 주의점

* 주의할 점
  * 하위 도메인의 모델이 뒤섞이지 않도록 하는 것
  * 한 개의 BOUNDED CONTEXT에서 여러 하위 도메인을 포함하더라도, 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 한다.

    * 이를 통해 하위 도메인을 위한 모델이 서로 뒤섞이지 않아서, 하위 도메인마다 BOUNDED CONTEXT를 갖는 효과를 낼 수 있다.

![](../../.gitbook/assets/image%20%2830%29.png)

* BOUNDED CONTEXT 는 도메인 모델을 구분하는 경계가 되기 때문에, BOUNDED CONTEXT는 구현하는 하위 도메인에 알맞은 모델을 포함한다.
  * 같은 사용자라 하더라도 주문 BOUNDED CONTEXT와

    회원 BOUNDED CONTEXT가 갖는 모델이 달라진다.

  * 또한 같은 상품이라도 카탈로그 BOUNDED CONTEXT의 Product 와 재고 BOUNDED CONTEXT의 Product 는 각 컨텍스트에 맞는 모델을 갖는다.
  * 따라서, 회원의 Member 는 애그리거트 루트이지만 , 주문의 Orderer는 밸류가 되고
  * 카탈로그의 Product는 상품이 속할 Category와 연관을 갖지만, 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.

![](../../.gitbook/assets/image%20%2826%29.png)

## 03 .BOUNDED CONTEXT의 구현

### 1 . BOUNDED CONTEXT의 범위

* BOUNDED CONTEXT 는 도메인 모델만 포함하는 것은 아니다.
  * 도메인 모델 뿐만 아니라, 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라 영역 등을 모두 포함한다.
  * 도메인 모델의 구조가 바뀌면, 테이블 스키마도 함께 변경해야 하므로, 해당 테이블도 BOUNDED CONTEXT에 포함된다.
  * 즉, 도메인 기능을 제공하는 데 필요한 요소들을 모두 포함한다.
* 모든 BOUNDED CONTEXT를 반드시 도메인 주도로 개발할 필요는 없다.

  * 상품의 리뷰는 복잡한 도메인로직을 갖지 않기 때문에, CRUD 방식으로 구현해도 된다.

    * 즉, DAO와 데이터 중심의 밸류 객체를 이용해서, 리뷰 기능을 구현해도 기능을 유지보수하는데 큰 문제가 없다.

![](../../.gitbook/assets/image%20%2837%29.png)

* 한 BOUNDED CONTEXT 에서 두 방식을 혼합해서 사용할 수도 있다.
  * 대표적인 예시 : CQRS 패턴
    * CQRS\[Common Query Responsibility Segregation\]
      * 상태를 변경하는 명령 기능과, 기능을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴
      * 예시
        * 단일 BOUNDED CONTEXT에 적용하여, 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현하고,
        * 조회 기능은 서비스 - DAO 를 이용해서 구현할 수 있다.

![](../../.gitbook/assets/image%20%2839%29.png)



* 각 BOUNDED CONTEXT는 서로 다른 구현 기술을 사용할 수도 있다.
  * 웹 MVC 는 스프링 MVC를 사용하고 , 리포지터리 구현 기술로는 JPA/하이버네이트를 사용하는 BOUNDED CONTEXT가 존재할 수 있다.
* BOUNDED CONTEXT가 반드시 사용자에 보여지는 UI를 가져야 하는 것은 아니다.
  * 1 . 웹 브라우저를 사용하거나,
  * 2 . BOUNDED CONTEXT를 위한 파사드 역할을 하는 UI 서버를 사용한다.

## 04 . BOUNDED CONTEXT간 통합

### 1 . ㅇㅇ

* 
## 05 .BOUNDED CONTEXT간 관계

### 1 . 한쪽에서 API를 제공, 다른 한쪽에서 API를 호출하는 관계

* 대표적 예시
  * REST API
    * API를 사용하는 BOUNDED CONTEXT 는 API를 제공하는 BOUNDED CONTEXT에 의존하게 된다.

![](../../.gitbook/assets/image%20%2835%29.png)



* 하류\[Downstream\] 컴포넌트인 카탈로그 컨텍스트는 상류\[Upstream\]컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존한다.
* 카탈로그는 추천 상품을 보여주기 위해 추천 BOUNDED CONTEXT 가 제공하는 REST API를 호출한다.
  * 추천 시스템이 제공하는 REST API의 인터페이스가 바뀌면, 카탈로그 시스템의 코드도 바뀌게 된다.
* 이렇게, 상류 컴포넌트는 일종의 서비스 공급자 역할을 하며, 하류 컴포넌트는 그 서비스를 사용하는 고객 역할을 한다.
  * 상류가 API를 마음대로 변경하게 되면, 하류는 변경에 맞추느라, 우선순위가 높은 다른 기능을 개발하지 못할 수 있다.
  * 반대로, 상류가 무엇인가를 변경할 때마다 하류로부터 여러 절차를 거쳐 승낙을 받아야 한다면 상류는 새로운 개발 시도 자체를 하지 않을 수 있다.
  * 따라서, 상류팀과 하류팀은 개발 계획을 서로 공유하고 일정을 협의해서 결정해야 한다.
* 상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다.
  * 상류 팀의 고객인 하류 팀이 다수 존재하면, 상류 팀은 여러 하류 팀의 요구사항들을 수용할 수 있는 API를 만들고, 이를 서비스 형태로 공개해서 , 서비스의 일관성을 유지할 수 있다.
  * 이러한 서비스를 가리켜

    \[공개 호스트 서비스\(OPEN HOST SERVICE\)\]라고 한다.

    * ex\) 검색 기능
      * 여러 서비스를 제공하는 포탈은 각 서비스별로 검색 기능을 구현하기보다는 , 검색을 위한 전용 시스템을 구축하고, 검색시스템과 각 시스템을 통합한다.
      * 이때, 검색시스템은 상류 컴포넌트, 블로그, 카페, 게시판은 하류 컴포넌트가 된다.
      * 상류 팀은 하류 컴포넌트의 요구사항을 수용하는 단일 API를 만들어 이를 공개하고, 각 하류 팀은 공개된 API를 사용하여 검색 기능을 구현하게 된다.

![](../../.gitbook/assets/image%20%2821%29.png)



* 상류 컴포넌트의 서비스는 상류 BOUNDED CONTEXT의 도메인 모델을 따른다.
  * 따라서, 하류 컴포넌트는 상류 서비스 모델이 자신의 도메인 모델에 영향을 쥦 않도록 보호해주는 완충지대를 만들어야 한다.
    * 안티코럽션 계층\[Anticorruption Layer\]
      * 외부 시스템의 도메인 모델이 내 도메인 모델을 침범하지 않도록 막아주는 역할

### 2 . 두 BOUNDED CONTEXT가 같은 모델을 공유하는 경우

* 공유 커널\[SHARED KERNEL\]
  * 두 팀이 공유하는 모델
    * 예시\) 운영자를 위한 주문 관리 도구를 개발하는 팀과 고객을 위한 주문 서비스를 개발하는 팀이 다르다고 가정
      * 두 팀은 표현하는 모델을 공유함으로써, 주문과 관련된 중복 개발을 막을 수 있다.
* 공유 커널의 장점
  * 중복을 줄여준다.
    * 두 팀이 하나의 모델을 개발해서 공유하기 때문에 , 두 팀에서 동일한 모델을 두 번 개발하는 중복을 줄일 수 있다.
* 공유 커널의 단점
  * 두 팀이 한 모델을 공유하기 때문에, 한 팀에서 임의로 모델을 변경해서는 안되며, 두 팀이 밀접한 관계를 유지해야 한다.
    * 만약 두 팀이 밀접한 관계를 형성할 수 없다면, 공유 커널을 사용할 때의 장점보다 공유 커널로 인한 개발 지연, 정체 문제가 더 커지게 된다.

### 3. 독립 방식\[SEPARATE WAY\] 관계

* 독립 방식 관계
  * 서로 통합하지 않는 방식
    * 두 BOUNDED CONTEXT 간에 통합을 하지 않으므로, 서로 독립적으로 모델을 발전시킨다.
* 독립 방식에서 두 BOUNDED CONTEXT 간의 통합은 수동으로 이루어진다.
  * 예시\)
    * 온라인 쇼핑몰솔루션과 이부의 ERP 서비스를 사용하고 있을 경우
      * 온라인 쇼핑몰 솔류선은 외부 erp 서비스와의 연동을 지원하지 않으므로, 온라인 쇼핑몰에서 판매가 발생하면, 쇼핑몰 운영자는 쇼핑몰 시스템에서 판매 정보를 보고 ERP 시스템에 입력해야 한다.

![](../../.gitbook/assets/image%20%2828%29.png)



* 수동 통합의 한계
  * 규모가 커질수록 통합이 어려워진다.
  * 따라서 두 BOUNDED CONTEXT를 통합해야 한다.
    * 이때 왜부에서 구매한 솔루션과 ERP를 완전히 대체할 수 없다면, 두 BOUNDED CONTEXT를 통합해주는 별도의 시스템을 만들어야 할 수도 있다.

![](../../.gitbook/assets/image%20%2832%29.png)



## 06 . 컨텍스트 맵

### 1. 컨텍스트 맵의 필요성

* 개별 BOUNDED CONTEXT에 매몰되면 전체를 보지 못할 때가 잇다.
  * 따라서 전체 비지니스를 조망할 수 있는 지도가 필요하다.
  * 이 역할을 하는 것이 바로 \[컨텍스트 맵\]이다.
* 컨텍스트 맵
  * BOUNDED CONTEXT 간의 관계를 표시한 것
    * CF\)
      * OHS
        * 오픈 호스트 서비스
      * ACL
        * 안티코럽션 계층

![](../../.gitbook/assets/image%20%2823%29.png)

* 컨텍스트 맵을 사용하면, BOUNDED CONTEXT의 경계가 명확하게 드러나고 , 서로 어떤 관계를 맺고 있는지 알 수 있다.
* 또한 BOUNDED CONTEXT영역에 주요 애그리거트를 함께 표시하면 모델에 대한 관계가 더 명확히 드러난다.
* 컨텍스트맵을 통해 시스템의 전체 구조를 보여줌으로써, 하위 도메인과 일치하지 않는 BOUNDED CONTEXT를 찾아 도메인에 맞게 BOUNDED CONTEXT를 조절하고,

  사업 역량을 어떤 BOUNDED CONTEXT에 집중할 지 파악하는데 도움이 된다.

* 컨텍스트 맵은 전체 시스템의 이해를 보여준다.
  * 따라서 시스템을 더 잘 이해하거나 시간이 지나면서 컨텍스트 간 관계가 바뀌게 되면 컨텍스트 맵도 함께 바뀌게 된다.

